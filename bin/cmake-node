#!/usr/bin/env node

/*!
 * cmake-node - node.js toolchain for cmake
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/cmake-node
 */

'use strict';

process.title = 'cmake-node';

const cp = require('child_process');
const fs = require('fs');
const os = require('os');
const path = require('path');

/*
 * Constants
 */

const VERSION = '0.1.1';
const NAPI_VERSION = 8;
const NODE_BINARY = path.basename(process.execPath);
const MODULE_PATH = path.resolve(__dirname, '..', 'cmake');
const MINGW_PATH = path.join(MODULE_PATH, 'Toolchain', 'MinGW.cmake');
const DEF_PATH = path.resolve(__dirname, '..', 'etc', 'node.def');
const WASI_RUN_PATH = path.join(__dirname, '..', 'scripts', 'wasi-run');
const NODE_PREFIX = path.resolve(process.execPath, '..', '..');
const WINDOWS = process.platform === 'win32';

const IGNORE_EXTS = [
  '.dll',
  '.dll.a',
  '.dylib',
  '.exp',
  '.ilk',
  '.lib',
  '.node',
  '.pdb',
  '.so',
  '.wasm',
  '.x'
];

const GYP_COMMANDS = [
  'build',
  'clean',
  'configure',
  'reconfigure',
  'rebuild',
  'install'
];

const UNIX_PREFIXES = [
  NODE_PREFIX,
  '/usr',
  '/usr/local',
  '/opt',
  '/opt/local'
];

const HELP = `
  Usage: cmake-node [options] [command] -- [cmake args]

  Options:

    -v, --version        output the version number
    -c, --config <type>  build type (default: Release)
    -C, --cmake <path>   path to cmake binary (default: cmake{,.exe})
    -d, --dist <url>     node.js dist url (windows only)
    -r, --root <path>    path to root directory (default: .)
    -l, --location       print location of the include directory
    -f, --fallback       fall back to node-gyp if cmake is not found
    -g, --gyp <path>     path to node-gyp binary (default: node-gyp{,.cmd})
    -p, --production     clean all files except for .node files
    --node-bin <name>    name of node binary (windows only)
    --node-def <name>    path to node.def (windows only)
    --node-lib <path>    path to node.lib (windows only)
    --node-exp <path>    path to node.exp/libnode.x (aix/zos only)
    -M, --mingw          cross-compile for win32 using mingw
    -W, --wasm           cross-compile for wasm using wasi-sdk
    --wasi-sdk <path>    path to wasi-sdk
    -A, --arch <arch>    select mingw arch (x86 or x64)
    -h, --help           output usage information

  Commands:

    install              install necessary files
    clear                clear cache
    configure            configure package
    build                build package
    clean                clean root directory
    reconfigure          reconfigure package
    rebuild              rebuild package
    ui                   open ui for package (ccmake/cmake-gui)

  node@${process.versions.node} - ${process.execPath}
  napi@${NAPI_VERSION} - ${path.resolve(__dirname, '..', 'include', 'node')}
  cmake-node@${VERSION} - ${__filename}
`;

/*
 * Commands
 */

async function install(options, args) {
  if (WINDOWS)
    await getWin32Lib(options);
  else if (options.platform === 'mingw')
    getMingwLib(options);
}

async function clear(options, args) {
  remove(getCacheDirectory());
}

async function configure(options, args) {
  const build = getBuildDirectory(options);

  mkdirp(build, 0o755);

  args = prependModulePath(args);

  if (WINDOWS) {
    const NODE_LIB = options.lib || (await getWin32Lib(options));

    exec(options.cmake, ['-D', `NODE_BIN=${options.bin}`,
                         '-D', `NODE_LIB=${NODE_LIB}`,
                         ...args, '..'], build);
  } else {
    const argv = [
      '-G', 'Unix Makefiles',
      '-D', `CMAKE_BUILD_TYPE=${options.config}`
    ];

    if (process.platform === 'aix' || process.platform === 'os390') {
      const NODE_EXP = options.exp || getNodeExp();

      argv.push('-D', `NODE_EXP=${NODE_EXP}`);
    }

    if (options.platform === 'mingw') {
      const MINGW_ARCH = options.arch === 'x64' ? 'x86_64' : 'i686';
      const NODE_LIB = options.lib || getMingwLib(options);

      argv.push('-D', `CMAKE_TOOLCHAIN_FILE=${MINGW_PATH}`);
      argv.push('-D', `MINGW_ARCH=${MINGW_ARCH}`);
      argv.push('-D', `NODE_BIN=${options.bin}`);
      argv.push('-D', `NODE_LIB=${NODE_LIB}`);
    }

    if (options.platform === 'wasm') {
      const WASI_PATH = path.join(options.wasi, 'share',
                                                'cmake',
                                                'wasi-sdk.cmake');

      argv.push('-D', `CMAKE_TOOLCHAIN_FILE=${WASI_PATH}`);
      argv.push('-D', `CMAKE_CROSSCOMPILING_EMULATOR=${WASI_RUN_PATH}`);
      argv.push('-D', `WASI_SDK_PREFIX=${options.wasi}`);

      process.env.NODEJS = process.execPath;
    }

    argv.push(...args);
    argv.push('../..');

    exec(options.cmake, argv, build);
  }
}

async function build(options, args) {
  const build = getBuildDirectory(options);

  mkdirp(build, 0o755);

  if (WINDOWS) {
    exec(options.cmake, ['--build', '.',
                         '--config', options.config,
                         ...args], build);
  } else {
    exec(options.cmake, ['--build', '.', ...args], build);
  }

  if (options.production)
    await clean(options, []);
}

async function clean(options, args) {
  const build = path.join(options.root, 'build');

  if (options.production)
    remove(build, IGNORE_EXTS);
  else
    remove(build);
}

async function reconfigure(options, args) {
  const build = getBuildDirectory(options);
  const cache = path.join(build, 'CMakeCache.txt');

  remove(cache);

  await configure(options, args);
}

async function rebuild(options, args) {
  await clean({ root: options.root }, []);
  await configure(options, args);
  await build(options, []);
}

async function ui(options, args) {
  const build = getBuildDirectory(options);

  mkdirp(build, 0o755);

  let name = WINDOWS ? 'cmake-gui.exe' : 'ccmake';

  if (isPath(options.cmake))
    name = path.resolve(options.cmake, '..', name);

  exec(name, [...args, '.'], build, false);
}

/*
 * Argument Parsing
 */

function parseArgs(argv) {
  const options = {
    config: 'Release',
    cmake: findCMake(),
    dist: 'https://nodejs.org/dist',
    root: '.',
    fallback: false,
    production: false,
    gyp: null,
    bin: NODE_BINARY,
    def: DEF_PATH,
    lib: null,
    exp: null,
    platform: '',
    wasi: '/opt/wasi-sdk',
    arch: 'x64',
    cmd: null,
    args: []
  };

  const args = getArgs(argv);

  let done = false;

  for (let i = 2; i < args.length; i++) {
    const arg = args[i];

    if (done) {
      options.args.push(arg);
      continue;
    }

    let next = '';

    if (i + 1 < args.length)
      next = args[i + 1];

    switch (arg) {
      case '-v':
      case '--version': {
        process.stdout.write(VERSION + '\n');
        process.exit(0);
        break;
      }

      case '-c':
      case '--config': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.config = next;

        i += 1;

        break;
      }

      case '-C':
      case '--cmake': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.cmake = next;

        i += 1;

        break;
      }

      case '-d':
      case '--dist': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.dist = next;

        i += 1;

        break;
      }

      case '-r':
      case '--root': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.root = next;

        i += 1;

        break;
      }

      case '-l':
      case '--location': {
        process.stdout.write(MODULE_PATH + '\n');
        process.exit(0);
        break;
      }

      case '-f':
      case '--fallback': {
        options.fallback = true;
        break;
      }

      case '-g':
      case '--gyp': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.gyp = next;

        i += 1;

        break;
      }

      case '-p':
      case '--production': {
        options.production = true;
        break;
      }

      case '--node-bin': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.bin = next;

        i += 1;

        break;
      }

      case '--node-def': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.def = path.resolve(next);

        if (!fs.existsSync(options.def))
          throw new Error(`Invalid node.def path: '${next}'.`);

        i += 1;

        break;
      }

      case '--node-lib': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.lib = path.resolve(next);

        if (!fs.existsSync(options.lib))
          throw new Error(`Invalid node.lib path: '${next}'.`);

        i += 1;

        break;
      }

      case '--node-exp': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.exp = path.resolve(next);

        if (!fs.existsSync(options.exp))
          throw new Error(`Invalid node.exp path: '${next}'.`);

        i += 1;

        break;
      }

      case '-M':
      case '--mingw': {
        if (WINDOWS)
          throw new Error('MinGW not supported on Windows.');

        options.platform = 'mingw';

        if (options.bin === NODE_BINARY)
          options.bin = 'node.exe';

        break;
      }

      case '-W':
      case '--wasm': {
        if (WINDOWS)
          throw new Error('WASM not supported on Windows.');

        options.platform = 'wasm';

        break;
      }

      case '--wasi-sdk': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.wasi = path.resolve(next);

        if (!fs.existsSync(options.wasi))
          throw new Error(`Invalid wasi-sdk path: '${next}'.`);

        i += 1;

        break;
      }

      case '-A':
      case '--arch': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        switch (next) {
          case 'x86':
          case 'i386':
          case 'i486':
          case 'i586':
          case 'i686':
            next = 'x86';
            break;
          case 'x64':
          case 'x86_64':
          case 'x86-64':
          case 'amd64':
            next = 'x64';
            break;
          default:
            throw new Error(`Invalid architecture: '${next}'.`);
        }

        options.arch = next;

        i += 1;

        break;
      }

      case '-h':
      case '--help': {
        process.stdout.write(HELP + '\n');
        process.exit(0);
        break;
      }

      case '--': {
        done = true;
        break;
      }

      default: {
        if (arg.length === 0 || arg[0] === '-' || options.cmd)
          throw new Error(`Invalid argument: ${arg}.`);

        options.cmd = arg;

        break;
      }
    }
  }

  if (!options.cmd) {
    process.stdout.write(HELP + '\n');
    process.exit(0);
  }

  return options;
}

/*
 * Main
 */

const commands = {
  __proto__: null,
  install,
  clear,
  configure,
  build,
  clean,
  reconfigure,
  rebuild,
  ui
};

async function main(argv) {
  const options = parseArgs(argv);

  if (shouldFallback(options)) {
    if (options.production && options.cmd === 'clean') {
      await clean(options, []);
      return;
    }

    runGYP(options.gyp, options.cmd, options.root);

    if (options.production && options.cmd.endsWith('build'))
      await clean(options, []);

    return;
  }

  if (!hasExecutable(options.cmake))
    throw new Error(`CMake not available (${options.cmake}).`);

  if (!isCMakeRoot(options.root))
    throw new Error(`Invalid CMake root: ${options.root}`);

  if (!commands[options.cmd])
    throw new Error(`Unknown command: ${options.cmd}.`);

  await commands[options.cmd](options, options.args);
}

/*
 * Installation Files
 */

async function getWin32Lib(options) {
  // Explanation: It's impossible to build a DLL
  // with unresolved symbols. As a result, when
  // node.js is built, a .lib file is created,
  // exposing stubs for all necessary symbols.
  //
  // When building an addon, MSVS must link to
  // this .lib file. Unfortunately, this .lib
  // file is specific to both the node version
  // and the architecture.
  //
  // We try to generate the import library on
  // the fly. This is in contrast to other build
  // systems which attempt to download it from
  // nodejs.org.
  const base = options.bin.split('.')[0];
  const name = `${base}-${process.arch}-${NAPI_VERSION}.lib`;
  const file = path.join(getCacheDirectory(), name);
  const machine = process.arch.toUpperCase();

  if (fs.existsSync(file))
    return file;

  mkdirp(path.dirname(file), 0o755);

  console.log('Looking for lib.exe...');

  let lib = findLib(options.cmake);

  if (!lib) {
    console.error('WARNING: Could not find lib.exe.');

    lib = 'lib.exe'; // Try lib.exe. We might get lucky.
  } else {
    console.log('Found lib.exe: %s', lib);
  }

  console.log('Creating %s...', name);

  const result = tryExec(lib, [`/OUT:${file}`,
                               `/DEF:${options.def}`,
                               `/NAME:${options.bin}`,
                               `/MACHINE:${machine}`]);

  if (!result) {
    if (base !== 'node')
      throw new Error(`Could not create ${name}.`);

    console.error('WARNING: Could not create %s.', name);

    // Try to download the import library
    // from nodejs.org as a last resort.
    return getNodeLib(options.dist);
  }

  return file;
}

function getMingwLib(options) {
  const base = options.bin.split('.')[0];
  const name = `${base}-${options.arch}-${NAPI_VERSION}.lib`;
  const file = path.join(getCacheDirectory(), name);
  const prefix = options.arch === 'x64' ? 'x86_64' : 'i686';
  const dlltool = `${prefix}-w64-mingw32-dlltool`;
  const machine = 'i386:x86-64';

  if (fs.existsSync(file))
    return file;

  mkdirp(path.dirname(file), 0o755);

  const result = tryExec(dlltool, ['-y', file,
                                   '-d', options.def,
                                   '-D', options.bin,
                                   '-m', machine]);

  if (!result)
    throw new Error(`Could not create ${name}.`);

  return file;
}

async function getNodeLib(dist) {
  const arch = process.arch;
  const version = process.version.split('-')[0].substring(1);
  const url = `${dist}/v${version}/win-${arch}/node.lib`;
  const name = `node-${arch}-${version}.lib`;
  const file = path.join(getCacheDirectory(), name);

  if (!fs.existsSync(file))
    await download(url, file);

  return file;
}

function getNodeExp() {
  let name;

  if (process.platform === 'aix')
    name = '/include/node/node.exp';
  else
    name = '/lib/libnode.x';

  const file = path.join(NODE_PREFIX, name);

  if (!fs.existsSync(file))
    throw new Error(`Could not find exports file: ${file}`);

  return file;
}

/*
 * Helpers
 */

function getArgs(argv) {
  const args = [];

  let done = false;

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    if (done) {
      args.push(arg);
      continue;
    }

    if (i >= 2 && arg === '--') {
      args.push(arg);
      done = true;
      continue;
    }

    if (arg.startsWith('--')) {
      // e.g. --opt
      const index = arg.indexOf('=');
      if (index !== -1) {
        // e.g. --opt=val
        args.push(arg.substring(0, index));
        args.push(arg.substring(index + 1));
      } else {
        args.push(arg);
      }
    } else if (arg.startsWith('-')) {
      if (arg.length > 2) {
        // e.g. -abc
        for (let j = 1; j < arg.length; j++)
          args.push(`-${arg.charAt(j)}`);
      } else {
        // e.g. -a
        args.push(arg);
      }
    } else {
      // e.g. foo
      args.push(arg);
    }
  }

  return args;
}

function getCacheDirectory() {
  if (WINDOWS) {
    // See: https://github.com/sindresorhus/env-paths
    let {LOCALAPPDATA} = process.env;

    if (!LOCALAPPDATA)
      LOCALAPPDATA = path.resolve(os.homedir(), 'AppData', 'Local');

    return path.resolve(LOCALAPPDATA, 'cmake-node', 'Cache');
  }

  return path.resolve(os.homedir(), '.cache', 'cmake-node');
}

function getBuildDirectory(options) {
  if (WINDOWS)
    return path.join(options.root, 'build');

  return path.join(options.root, 'build', options.config);
}

function prependModulePath(args) {
  // See: https://github.com/chjj/cmake-node/issues/1
  const mpath = WINDOWS ? MODULE_PATH.replace(/\\/g, '/') : MODULE_PATH;
  const out = ['-D', ''];

  let paths = null;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    let next = '';

    if (i + 1 < args.length)
      next = args[i + 1];

    if (arg === '-D' && next.startsWith('CMAKE_MODULE_PATH=')) {
      paths = next.substring(18);
      i += 1;
      continue;
    }

    if (arg.startsWith('-DCMAKE_MODULE_PATH=')) {
      paths = arg.substring(20);
      continue;
    }

    out.push(arg);
  }

  if (paths)
    paths = `${mpath};${paths}`;
  else
    paths = mpath;

  out[1] = `CMAKE_MODULE_PATH=${paths}`;

  return out;
}

function isCMakeRoot(root) {
  return fs.existsSync(path.join(root, 'CMakeLists.txt'));
}

function isGYPRoot(root) {
  return fs.existsSync(path.join(root, 'binding.gyp'));
}

function exec(file, args, cwd = '.', windowsHide = true) {
  const result = cp.spawnSync(file, args, {
    cwd: path.resolve(cwd),
    stdio: 'inherit',
    windowsHide
  });

  if (result.error)
    throw result.error;

  if (result.signal)
    process.kill(process.pid, result.signal);

  if (result.status)
    process.exit(result.status);
}

function tryExec(file, args) {
  let result;

  try {
    result = cp.spawnSync(file, args, {
      stdio: 'ignore',
      windowsHide: true
    });
  } catch (e) {
    return false;
  }

  return !result.error && !result.signal && result.status === 0;
}

function hasExecutable(file) {
  return tryExec(file, ['--version']);
}

function shouldFallback(options) {
  if (!options.fallback)
    return false;

  if (!GYP_COMMANDS.includes(options.cmd))
    return false;

  if (!isGYPRoot(options.root))
    return false;

  return !isCMakeRoot(options.root)
      || !hasExecutable(options.cmake);
}

function findCMake() {
  const cmake = WINDOWS ? 'cmake.exe' : 'cmake';

  if (hasExecutable(cmake))
    return cmake;

  const paths = [];

  if (WINDOWS) {
    for (const prefix of [process.env.LOCALAPPDATA,
                          process.env.PROGRAMFILES,
                          process.env['PROGRAMFILES(X86)']]) {
      if (!prefix)
        continue;

      paths.push(path.join(prefix, 'CMake', 'bin', 'cmake.exe'));
    }
  } else {
    for (const prefix of UNIX_PREFIXES)
      paths.push(path.join(prefix, 'bin', 'cmake'));
  }

  for (const path_ of paths) {
    if (fs.existsSync(path_))
      return path_;
  }

  return cmake;
}

function findGYP(root) {
  const gyp = WINDOWS ? 'node-gyp.cmd' : 'node-gyp';

  if (hasExecutable(gyp))
    return gyp;

  const paths = [];

  if (WINDOWS) {
    let {APPDATA} = process.env;

    if (!APPDATA)
      APPDATA = path.resolve(os.homedir(), 'AppData', 'Roaming');

    paths.push(path.resolve(process.execPath,
                            '..',
                            'node_modules',
                            'npm',
                            'node_modules',
                            'node-gyp',
                            'bin',
                            'node-gyp.js'));

    paths.push(path.resolve(APPDATA,
                            'npm',
                            'node_modules',
                            'node-gyp',
                            'bin',
                            'node-gyp.js'));
  } else {
    for (const prefix of UNIX_PREFIXES) {
      const modules = path.join(prefix, 'lib', 'node_modules');

      paths.push(path.join(modules,
                           'node-gyp',
                           'bin',
                           'node-gyp.js'));

      paths.push(path.join(modules,
                           'npm',
                           'node_modules',
                           'node-gyp',
                           'bin',
                           'node-gyp.js'));
    }
  }

  paths.push(path.resolve(root,
                          'node_modules',
                          'node-gyp',
                          'bin',
                          'node-gyp.js'));

  for (const path_ of paths) {
    if (fs.existsSync(path_))
      return path_;
  }

  return gyp;
}

function runGYP(gyp, cmd, root) {
  if (gyp == null)
    gyp = findGYP(root);

  if (cmd === 'reconfigure')
    cmd = 'configure';

  if (path.extname(gyp) === '.js') {
    gyp = path.resolve(gyp);

    if (!fs.existsSync(gyp))
      throw new Error(`GYP not available (${gyp}).`);

    exec(process.execPath, [gyp, cmd], root);
  } else {
    if (!hasExecutable(gyp))
      throw new Error(`GYP not available (${gyp}).`);

    exec(gyp, [cmd], root);
  }
}

function findLib(cmake) {
  // Abuse CMake to find out where MSVC is.
  const dir = path.join(getCacheDirectory(), 'project');
  const file = path.join(dir, 'CMakeLists.txt');

  if (!fs.existsSync(file)) {
    mkdirp(dir, 0o755);

    fs.writeFileSync(file, 'project(x LANGUAGES C)\n'
                         + 'message(STATUS "@@@CC=${CMAKE_C_COMPILER}@@@")\n');
  }

  let result;

  try {
    result = cp.spawnSync(cmake, ['.'], {
      cwd: dir,
      stdio: ['ignore', 'pipe', 'ignore'],
      windowsHide: true
    });
  } catch (e) {
    return null;
  }

  const m = /@@@CC=(.+?)@@@/.exec(result.stdout);

  if (!m)
    return null;

  const cl = path.normalize(m[1]); // cl.exe
  const bin = path.dirname(cl); // /path/to/msvc/bin
  const lib = path.join(bin, 'lib.exe');

  if (!fs.existsSync(lib))
    return null;

  return lib;
}

function isPath(str) {
  if (WINDOWS && str.includes('/'))
    return true;

  return str.includes(path.sep);
}

function safeStat(path_) {
  try {
    return fs.lstatSync(path_);
  } catch (e) {
    if (e.code === 'EPERM' && WINDOWS) {
      try {
        fs.chmodSync(path_, 0o666);
      } catch (e) {
        ;
      }
      return fs.lstatSync(path_);
    }
    throw e;
  }
}

function remove(path_, ignore = []) {
  path_ = path.normalize(path_);

  let tries = 0;

  for (;;) {
    try {
      _remove(path_, ignore);
    } catch (e) {
      const retry = e.code === 'EBUSY'
                 || e.code === 'ENOTEMPTY'
                 || e.code === 'EPERM'
                 || e.code === 'EMFILE'
                 || e.code === 'ENFILE';

      if (retry && tries < 5) {
        tries += 1;
        continue;
      }

      throw e;
    }

    break;
  }
}

function _remove(path_, ignore) {
  let stat = null;

  if (ignore.length > 0) {
    const ext = path.extname(path_);

    if (ignore.includes(ext))
      return 1;
  }

  try {
    stat = safeStat(path_);
  } catch (e) {
    if (e.code === 'ENOENT')
      return 0;
    throw e;
  }

  if (stat.isDirectory()) {
    let list = null;
    let flag = 0;
    let tries = 0;

    try {
      list = fs.readdirSync(path_);
    } catch (e) {
      if (e.code === 'ENOENT')
        return 0;
      throw e;
    }

    for (const name of list)
      flag |= _remove(path.join(path_, name), ignore);

    while (!flag) {
      try {
        fs.rmdirSync(path_);
      } catch (e) {
        if (e.code === 'ENOENT')
          return 0;

        if (e.code === 'ENOTEMPTY' && WINDOWS) {
          if (tries < 5) {
            tries += 1;
            continue;
          }
        }

        throw e;
      }

      break;
    }

    return flag;
  }

  try {
    fs.unlinkSync(path_);
  } catch (e) {
    if (e.code === 'ENOENT')
      return 0;
    throw e;
  }

  return 0;
}

function getPaths(path_) {
  const paths = [];

  let dir = path.normalize(path_);

  for (;;) {
    paths.push(dir);

    const next = path.dirname(dir);

    if (next === dir)
      break;

    dir = next;
  }

  return paths.reverse();
}

function mkdirp(dir, mode) {
  if (mode == null)
    mode = 0o777;

  for (const path_ of getPaths(dir)) {
    try {
      const stat = fs.statSync(path_);
      if (!stat.isDirectory())
        throw new Error('ENOTDIR');
    } catch (e) {
      if (e.code === 'ENOENT')
        fs.mkdirSync(path_, mode);
      else
        throw e;
    }
  }
}

async function download(url, file) {
  return new Promise((resolve, reject) => {
    try {
      _download(url, file, resolve, reject);
    } catch (e) {
      reject(e);
    }
  });
}

function _download(url, file, resolve, reject) {
  const {parse} = require('url');
  const parsed = parse(url);
  const https = parsed.protocol === 'https:';
  const backend = https ? require('https') : require('http');

  const options = {
    method: 'GET',
    host: parsed.host,
    port: parsed.port || (https ? 443 : 80),
    path: parsed.path,
    agent: false
  };

  console.log('Downloading %s...', url);

  mkdirp(path.dirname(file), 0o755);

  const req = backend.request(options);

  let res = null;
  let write = null;
  let done = false;

  const destroy = (stream) => {
    try {
      if (stream)
        stream.destroy();
    } catch (e) {
      ;
    }
  };

  const error = (err) => {
    if (!done) {
      done = true;
      destroy(req);
      destroy(res);
      destroy(write);
      reject(err);
    }
  };

  const finish = () => {
    if (!done) {
      done = true;
      resolve();
    }
  };

  const handle = () => {
    res.on('error', error);

    if (res.statusCode !== 200)
      throw new Error(`Status code: ${res.statusCode}`);

    if (res.headers.location)
      throw new Error('HTTP request was redirected.');

    write = fs.createWriteStream(file);

    write.on('error', error);
    write.on('finish', finish);

    res.pipe(write);
  };

  req.on('response', (res_) => {
    res = res_;
    try {
      handle();
    } catch (e) {
      error(e);
    }
  });

  req.on('error', error);
  req.end();
}

/*
 * Execute
 */

main(process.argv).catch((err) => {
  if (err.code === 'ENOENT')
    process.stderr.write(`File not found: ${err.path}\n`);
  else
    process.stderr.write(err.message + '\n');

  process.exit(1);
});
