#!/usr/bin/env node

/*!
 * node-cmk - node.js toolchain for cmake
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/chjj/node-cmk
 */

'use strict';

process.title = 'node-cmk';

const assert = require('assert');
const cp = require('child_process');
const fs = require('fs');
const os = require('os');
const path = require('path');

/*
 * Constants
 */

const NODE_BIN = path.basename(process.execPath);
const TOOLCHAIN = path.resolve(__dirname, '..', 'cmake', 'node.cmake');

const VERSION = '0.0.1';

const HELP = `
  Usage: node-cmk [options] [command] -- [cmake args]

  Options:

    -v, --version        output the version number
    -c, --config <type>  build type (default: Release)
    -C, --cmake <path>   path to cmake binary (default: cmake/cmake.exe)
    -d, --dist <url>     node.js dist url (windows only)
    -r, --root <path>    path to root directory (default: .)
    -l, --location       print location of toolchain file
    -h, --help           output usage information

  Commands:

    install              install necessary files (windows only)
    configure            configure package
    build                build package
    clean                clean root directory
    reconfigure          reconfigure package
    rebuild              rebuild package (default)
`;

/*
 * Commands
 */

async function install(options, args) {
  if (process.platform === 'win32')
    await getNodeLib(options.dist);
}

async function configure(options, args) {
  if (process.platform === 'win32') {
    const NODE_LIB = await getNodeLib(options.dist);

    exec(options.cmake, ['-D', `NODE_BIN=${NODE_BIN}`,
                         '-D', `NODE_LIB=${NODE_LIB}`,
                         '-D', `CMAKE_TOOLCHAIN_FILE=${TOOLCHAIN}`,
                         ...args,
                         options.root]);
  } else {
    const args = [
      '-G', 'Unix Makefiles',
      '-D', `CMAKE_TOOLCHAIN_FILE=${TOOLCHAIN}`
    ];

    if (options.config)
      args.push('-D', `CMAKE_BUILD_TYPE=${options.config}`);

    args.push(...args);
    args.push(options.root);

    exec(options.cmake, args);
  }
}

function build(options, args) {
  if (process.platform === 'win32') {
    exec(options.cmake, ['--build', options.root,
                         '--config', options.config || 'Release',
                         ...args]);
  } else {
    exec(options.cmake, ['--build', options.root, ...args]);
  }
}

function clean(options, args) {
  const traverse = (path_) => {
    const stat = fs.lstatSync(path_);

    if (stat.isDirectory()) {
      switch (path.basename(path_)) {
        case 'CVS':
        case '.git':
        case '.hg':
        case '.svn':
          return;
      }
    }

    if (isDirty(path_, stat)) {
      remove(path_);
      return;
    }

    if (stat.isDirectory()) {
      for (const name of fs.readdirSync(path_))
        traverse(path.join(path_, name));
    }
  };

  try {
    traverse(path.resolve(options.root));
  } catch (e) {
    ;
  }
}

function reconfigure(options, args) {
  remove(path.resolve(options.root, 'CMakeCache.txt'));
  configure(options, args);
}

function rebuild(options, args) {
  clean(options, []);
  configure(options, args);
  build(options, []);
}

/*
 * Argument Parsing
 */

function parseArgs(argv) {
  const options = {
    config: null,
    cmake: process.platform === 'win32'
        ? 'cmake.exe'
        : 'cmake',
    dist: 'https://nodejs.org/dist',
    root: '.',
    command: null,
    args: []
  };

  const args = getArgs(argv);

  let done = false;

  for (let i = 2; i < args.length; i++) {
    const arg = args[i];

    if (done) {
      options.args.push(arg);
      continue;
    }

    let next = '';

    if (i + 1 < args.length)
      next = args[i + 1];

    switch (arg) {
      case '-v':
      case '--version': {
        process.stdout.write(VERSION + '\n');
        process.exit(0);
        break;
      }

      case '-c':
      case '--config': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.config = next;

        i += 1;

        break;
      }

      case '-C':
      case '--cmake': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.cmake = next;

        i += 1;

        break;
      }

      case '-d':
      case '--dist': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.dist = next;

        i += 1;

        break;
      }

      case '-r':
      case '--root': {
        if (!next || next[0] === '-')
          throw new Error(`Invalid option for: ${arg}.`);

        options.root = next;

        i += 1;

        break;
      }

      case '-l':
      case '--location': {
        process.stdout.write(TOOLCHAIN + '\n');
        process.exit(0);
        break;
      }

      case '-h':
      case '--help': {
        process.stdout.write(HELP + '\n');
        process.exit(0);
        break;
      }

      case '--': {
        done = true;
        break;
      }

      default: {
        if (arg.length === 0 || arg[0] === '-')
          throw new Error(`Invalid argument: ${arg}.`);

        if (options.command)
          throw new Error('Already have command.');

        options.command = arg;

        break;
      }
    }
  }

  if (!options.command)
    options.command = 'rebuild';

  return options;
}

/*
 * Main
 */

const commands = {
  __proto__: null,
  install,
  configure,
  build,
  clean,
  reconfigure,
  rebuild
};

async function main(argv) {
  const options = parseArgs(argv);

  if (!isPackage(options.root))
    throw new Error(`Not a node.js packagae: ${options.root}.`);

  if (!commands[options.command])
    throw new Error(`Unknown command: ${options.command}.`);

  return commands[options.command](options, options.args);
}

/*
 * Installation Files
 */

async function getNodeLib(dist) {
  // Explanation: It's impossible to build a DLL
  // with unresolved symbols. As a result, when
  // node.js is built, a .lib file is created,
  // exposing all the necessary symbols.
  //
  // When building an addon, MSVS must link to
  // this .lib file. Unfortunately, this .lib
  // file is specific to both the node version
  // and the architecture.
  //
  // Further reading: http://edll.sourceforge.net/
  //
  // Node.js uses the ".def & .a" solution.
  const arch = process.arch;
  const version = process.version.split('-')[0];
  const url = `${dist}/${version}/win-${arch}/node.lib`;
  const name = `node-${version}-${arch}.lib`;

  // See: https://github.com/sindresorhus/env-paths
  let {LOCALAPPDATA} = process.env;

  if (!LOCALAPPDATA)
    LOCALAPPDATA = path.resolve(os.homedir(), 'AppData', 'Local');

  const file = path.resolve(LOCALAPPDATA, 'node-cmk', 'Cache', name);

  let stat = null;

  try {
    stat = fs.statSync(file);
  } catch (e) {
    ;
  }

  if (!stat || stat.size === 0)
    await download(url, file);

  return file;
}

/*
 * Windows Cleaning
 */

function isTargetDir(path_, stat) {
  if (!stat.isDirectory())
    return false;

  switch (path.basename(path_)) {
    case 'Debug':
    case 'Release':
    case 'MinSizeRel':
    case 'RelWithDebInfo':
      break;
    default:
      return false;
  }

  for (const name of fs.readdirSync(path_)) {
    if (path.extname(name) === '.lib')
      return true;
  }

  return false;
}

function isObjectDir(path_, stat) {
  if (!stat.isDirectory())
    return false;

  if (path.extname(path_) !== '.dir')
    return false;

  const list = fs.readdirSync(path_);

  return list.includes('Debug')
      || list.includes('Release')
      || list.includes('MinSizeRel')
      || list.includes('RelWithDebInfo');
}

function isArchDir(path_, stat) {
  if (!stat.isDirectory())
    return false;

  switch (path.basename(path_)) {
    case 'x86':
    case 'x64':
    case 'arm':
    case 'arm64':
      break;
    default:
      return false;
  }

  const list = fs.readdirSync(path_);

  return list.includes('Debug')
      || list.includes('Release')
      || list.includes('MinSizeRel')
      || list.includes('RelWithDebInfo');
}

function isVCXProj(path_, stat) {
  if (!stat.isFile())
    return false;

  if (path.extname(path_) !== '.vcxproj')
    return false;

  const text = fs.readFileSync(path_, 'utf8');

  return text.includes('cmake');
}

function isVCXProjFilters(path_, stat) {
  if (!stat.isFile())
    return false;

  if (path.extname(path_) !== '.filters')
    return false;

  const text = fs.readFileSync(path_, 'utf8');

  return text.includes('CMakeLists.txt')
      || text.includes('CMake Rules');
}

function isSLN(path_, stat) {
  if (!stat.isFile())
    return false;

  if (path.extname(path_) !== '.sln')
    return false;

  const text = fs.readFileSync(path_, 'utf8');

  return text.includes('ALL_BUILD.vcxproj');
}

/*
 * Unix Cleaning
 */

function isMakefile(path_, stat) {
  if (!stat.isFile())
    return false;

  if (path.basename(path_) !== 'Makefile')
    return false;

  const text = fs.readFileSync(path_, 'utf8');

  return text.includes('CMAKE generated file');
}

/*
 * Cleaning
 */

function isDirty(path_, stat) {
  switch (path.basename(path_)) {
    case 'CMakeCache.txt':
    case 'cmake_install.cmake':
    case 'DartConfiguration.tcl':
      return stat.isFile();
    case 'CMakeFiles':
      return stat.isDirectory();
  }

  // No way to properly identify these.
  switch (path.extname(path_)) {
    case '.a':
    case '.node':
      return stat.isFile();
    case '.dylib':
    case '.so':
      return stat.isFile() || stat.isSymbolicLink();
  }

  if (process.platform === 'win32') {
    return isTargetDir(path_, stat)
        || isObjectDir(path_, stat)
        || isArchDir(path_, stat)
        || isVCXProj(path_, stat)
        || isVCXProjFilters(path_, stat)
        || isSLN(path_, stat);
  }

  return isMakefile(path_, stat);
}

/*
 * Helpers
 */

function getArgs(argv) {
  assert(Array.isArray(argv));

  const args = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    assert(typeof arg === 'string');

    if (arg.startsWith('--')) {
      // e.g. --opt
      const index = arg.indexOf('=');
      if (index !== -1) {
        // e.g. --opt=val
        args.push(arg.substring(0, index));
        args.push(arg.substring(index + 1));
      } else {
        args.push(arg);
      }
    } else if (arg.startsWith('-')) {
      if (arg.length > 2) {
        // e.g. -abc
        for (let j = 1; j < arg.length; j++)
          args.push(`-${arg.charAt(j)}`);
      } else {
        // e.g. -a
        args.push(arg);
      }
    } else {
      // e.g. foo
      args.push(arg);
    }
  }

  return args;
}

function isPackage(dir) {
  try {
    fs.lstatSync(path.join(dir, 'package.json'));
    fs.lstatSync(path.join(dir, 'CMakeLists.txt'));
    return true;
  } catch (e) {
    return false;
  }
}

function spawn(file, args) {
  const result = cp.spawnSync(file, args, {
    stdio: 'inherit',
    windowsHide: true
  });

  if (result.error)
    throw result.error;

  return result;
}

function exec(file, args) {
  const result = spawn(file, args);

  if (result.signal)
    process.kill(process.pid, result.signal);

  if (result.status)
    process.exit(result.status);
}

function safeStat(path_) {
  try {
    return fs.lstatSync(path_);
  } catch (e) {
    if (e.code === 'EPERM' && process.platform === 'win32') {
      try {
        fs.chmodSync(path_, 0o666);
      } catch (e) {
        ;
      }
      return fs.lstatSync(path_);
    }
    throw e;
  }
}

function remove(path_) {
  path_ = path.normalize(path_);

  let tries = 0;

  for (;;) {
    try {
      _remove(path_);
    } catch (e) {
      const retry = e.code === 'EBUSY'
                 || e.code === 'ENOTEMPTY'
                 || e.code === 'EPERM'
                 || e.code === 'EMFILE'
                 || e.code === 'ENFILE';

      if (retry && tries < 5) {
        tries += 1;
        continue;
      }

      throw e;
    }

    break;
  }
}

function _remove(path_) {
  let stat = null;

  try {
    stat = safeStat(path_);
  } catch (e) {
    if (e.code === 'ENOENT')
      return;
    throw e;
  }

  if (stat.isDirectory()) {
    let list = null;

    try {
      list = fs.readdirSync(path_);
    } catch (e) {
      if (e.code === 'ENOENT')
        return;
      throw e;
    }

    for (const name of list)
      _remove(path.join(path_, name));

    let tries = 0;

    for (;;) {
      try {
        fs.rmdirSync(path_);
      } catch (e) {
        if (e.code === 'ENOENT')
          return;

        if (e.code === 'ENOTEMPTY' && process.platform === 'win32') {
          if (tries < 5 + 1) {
            tries += 1;
            continue;
          }
        }

        throw e;
      }

      break;
    }

    return;
  }

  try {
    fs.unlinkSync(path_);
  } catch (e) {
    if (e.code === 'ENOENT')
      return;
    throw e;
  }
}

function getPaths(path_) {
  const paths = [];

  let dir = path.normalize(path_);

  for (;;) {
    paths.push(dir);

    const next = path.dirname(dir);

    if (next === dir)
      break;

    dir = next;
  }

  return paths.reverse();
}

function mkdirp(dir, mode) {
  if (mode == null)
    mode = 0o777;

  for (const path_ of getPaths(dir)) {
    try {
      const stat = fs.statSync(path_);
      if (!stat.isDirectory())
        throw new Error('ENOTDIR');
    } catch (e) {
      if (e.code === 'ENOENT')
        fs.mkdirSync(path_, mode);
      else
        throw e;
    }
  }
}

async function download(url, file) {
  return new Promise((resolve, reject) => {
    try {
      _download(url, file, resolve, reject);
    } catch (e) {
      reject(e);
    }
  });
}

function _download(url, file, resolve, reject) {
  const {parse} = require('url');
  const parsed = parse(url);
  const https = parsed.protocol === 'https:';
  const backend = https ? require('https') : require('http');

  const options = {
    method: 'GET',
    host: parsed.host,
    port: parsed.port || (https ? 443 : 80),
    path: parsed.path,
    agent: false
  };

  process.stdout.write(`Downloading ${url}...\n`);

  mkdirp(path.dirname(file));

  const req = backend.request(options);

  const handle = (res) => {
    if (res.statusCode !== 200)
      throw new Error(`Status code: ${res.statusCode}`);

    if (res.headers.location)
      throw new Error('HTTP request was redirected.');

    res.on('error', reject);

    const stream = fs.createWriteStream(file);

    stream.on('error', reject);
    stream.on('finish', resolve);

    res.pipe(stream);
  };

  req.on('response', (res) => {
    try {
      handle(res);
    } catch (e) {
      reject(e);
    }
  });

  req.on('error', reject);
  req.end();
}

/*
 * Execute
 */

main(process.argv).catch((err) => {
  process.stderr.write(err.message + '\n');
  process.exit(1);
});
